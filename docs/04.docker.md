## Docker
<img src="https://raw.githubusercontent.com/vadim-bikmetov/interview/main/images/docker.png" width="200" alt="Docker">
1. Что такое Docker? В чем отличие контейнера от образа?

<details>
  <summary>Ответ</summary>

Docker - программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации.

Образ - шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".

Контейнер - запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".

</details>

---

2. Какие инструкции есть у Dockerfile?
<details>
  <summary>Ответ</summary>

| Инструкция | Описание |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FROM | Задаёт базовый (родительский) образ. |
| LABEL | Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ. |
| ENV | Устанавливает постоянные переменные среды. |
| RUN | Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов. |
| COPY | Копирует в контейнер файлы и директории. |
| ADD | Копирует файлы и директории в контейнер, может распаковывать локальные .tar-файлы. |
| CMD | Описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD. |
| WORKDIR | Задаёт рабочую директорию для следующей инструкции. |
| ARG | Задаёт переменные для передачи Docker во время сборки образа. |
| ENTRYPOINT | Предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются. |
| EXPOSE | Указывает на необходимость открыть порт. |
| VOLUME | Создаёт точку монтирования для работы с постоянным хранилищем. |

</details>
---

3. Чем отличается *CMD* от *ENTRYPOINT* в Dockerfile?

<details>
  <summary>Ответ</summary>

Инструкции CMD и ENTRYPOINT выполняются в момент запуска контейнера, тольо инструкция CMD позволяет переопределить передаваемые команде аргументы.

**Пример 1. CMD:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
CMD ["ping", "8.8.8.8"]  
```
В инструкцию CMD передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=32.976 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=31.998 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=31.843 ms
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 31.708/33.316/36.823 ms
```
Теперь передадим 2 новых аргумента для запуска контейнера.
```
$ docker run test traceroute 1.1.1.1
traceroute to 1.1.1.1 (1.1.1.1), 30 hops max, 46 byte packets
 1  172.17.0.1 (172.17.0.1)  0.017 ms  0.016 ms  0.009 ms
 2  192.168.168.1 (192.168.168.1)  0.996 ms  1.553 ms  2.069 ms
 3  *  *  *
 4  lag-2-435.bgw01.samara.ertelecom.ru (85.113.62.125)  1.454 ms  1.427 ms  1.984 ms
 5  172.68.8.3 (172.68.8.3)  19.685 ms  15.722 ms  15.565 ms
 6  172.68.8.2 (172.68.8.2)  15.846 ms  22.696 ms  35.093 ms
 7  one.one.one.one (1.1.1.1)  17.439 ms  17.670 ms  24.202 ms
```
`ping` заменен на traceroute, IP адрес заменен на 1.1.1.1.

**Пример 2. ENTRYPOINT:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
ENTRYPOINT ["ping", "8.8.8.8"]
```
В инструкцию ENTRYPOINT передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test2
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=36.189 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=44.120 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=44.584 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 36.189/41.631/44.584 ms
```
Теперь передадим изменим один из аргументов для запуска контейнера.
```
$ docker run test2 ping 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Как видим, аргумент передать контейнеру нельзя.

**Пример 3. ENTRYPOINT и CMD:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
ENTRYPOINT ["ping"]
CMD ["8.8.8.8"]
```
В инструкцию ENTRYPOINT передаётся аргумент `ping`, в CMD передаётся аргумент 8.8.8.8. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test3
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=41.176 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=32.875 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=40.395 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 32.875/38.148/41.176 ms
```
Пробуем изменить 2 аргумента.
```
$ docker run test3 traceroute 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Изменить 2 аргумента невозможно. Заменим аргумент инструкции CMD.
```
$ docker run test3 1.1.1.1    
PING 1.1.1.1 (1.1.1.1): 56 data bytes
64 bytes from 1.1.1.1: seq=0 ttl=58 time=31.412 ms
64 bytes from 1.1.1.1: seq=1 ttl=58 time=19.400 ms
64 bytes from 1.1.1.1: seq=2 ttl=58 time=15.814 ms
^C
--- 1.1.1.1 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 15.814/22.208/31.412 ms
```
При такой сборке образа команды ENTRYPOINT и CMD при запуске контейнера будут запущены последовательно, но аргумент возможно изменить только для CMD.

</details>
---

4. Чем отличается *COPY* от *ADD* в Dockerfile?

<details>
  <summary>Ответ</summary>

Инструкция *COPY* копируют файлы и директории с хостовой машины внутрь контейнера, инструкция *ADD* копирует файлы и директории с хостовой машины внутрь контейнера и может распаковывать .tar архивы.

</details>
---

5. Какие есть best practices для написания Dockerfile?

<details>
  <summary>Ответ</summary>

1. Запускать только один процесс на контейнер.
2. Стараться объединять несколько команд RUN в одну для уменьшения количества слоёв образа.
3. Частоизменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.
4. Указывать явные версии образов в инструкции FROM, чтобы избежать случая, когда выйдет новая версия образа с тегом latest.
5. При установке пакетов указывать версии пакетов.
6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
7. Использовать multistage build для сборки артифакта в одном контейнере и размещении его в другом.

</details>
---

6. Какие типы сетевых драйверов используются в docker?

<details>
  <summary>Ответ</summary>

Основные драйвера сетей docker: bridge, host, overlay, ipvlan, macvlan, none

**bridge:** это сетевой драйвер по умолчанию. Бридж сеть используется, когда ваши приложения запускаются в автономных контейнерах, которые должны взаимодействовать между собой. 
![docker-bridge](imgs/docker-bridge.png)
Взаимодействие с хостом выполняется через мост docker0 и конфигурацию таблицы iptables nat. В этом режиме будет выделено сетевое пространство имен, задан IP-адрес для каждого контейнера, а контейнер Docker на хосте будет подключен к виртуальному мосту. Виртуальный мост работает как физический коммутатор, поэтому все контейнеры на хосте подключены к сети уровня 2 через коммутатор.

**host:** использует сеть хоста напрямую без изоляции контейнера и хоста.

**none:** этот режим помещает контейнер в свой собственный сетевой стек, но не выполняет никакой настройки. Фактически, этот режим отключает сетевую функцию контейнера, что полезно в следующих двух ситуациях: контейнер не требует сети (например, только для пакетной задачи записи дисковых томов).

**macvlan:** в режиме Macvlan Bridge каждый контейнер имеет уникальный MAC-адрес, который используется для отслеживания сопоставления MAC-адреса с портом хоста Docker. Сеть драйвера Macvlan подключается к родительскому интерфейсу хоста Docker. Примерами являются физические интерфейсы, такие как eth0, субинтерфейс eth0.10 для тегирования VLAN 802.1q (.10 означает VLAN 10) или даже связанный хост-адаптер, который объединяет два интерфейса Ethernet в единый логический интерфейс. Назначенный шлюз является внешним по отношению к хосту, предоставляемому сетевой инфраструктурой. Каждая сеть Docker в режиме Macvlan Bridge изолирована друг от друга, и только одна сеть может быть подключена к родительскому узлу одновременно. Каждый хост-адаптер имеет теоретический предел, и каждый хост-адаптер может подключаться к сети Docker. Любой контейнер в той же подсети может взаимодействовать с любым другим контейнером в той же сети без шлюзового моста macvlan. Та же сетевая команда docker применяется к драйверу vlan. В режиме Macvlan без внешней маршрутизации процессов между двумя сетями / подсетями контейнеры в разных сетях не могут получить доступ друг к другу. Это также относится к нескольким подсетям в одной и той же терминальной сети.

**overlay:** Оверлейные сети соединяют несколько демонов Docker вместе и позволяют сервисам swarm взаимодействовать друг с другом. Вы также можете использовать оверлейные сети для облегчения связи между сервисом swarm и автономным контейнером или между двумя автономными контейнерами в разных демонах Docker. Эта стратегия устраняет необходимость выполнять маршрутизацию между этими контейнерами на уровне ОС.

**ipvlan:** Сети ipvlan предоставляют пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этой возможности, предоставляя операторам полный контроль над тегированием VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей.

</details>
---

7. Что такое эфемерные контейнеры?

<details>
  <summary>Ответ</summary>

[Эфемерные контейнеры](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/) стали бета-функцией в Kubernetes v1.23 и теперь включены по умолчанию.
Эфемерные контейнеры предназначены для транзитных задач, когда вам нужно временно [подключить дополнительный контейнер к существующему поду](https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container). Это идеально подходит для отладочных операций, когда вы хотите проверить поды, не затрагивая живые экземпляры контейнеров.

</details>
---

8. Что такое контейнер Docker?
<details>
  <summary>Ответ</summary>

Контейнер — базовая единица программного обеспечения, покрывающая код и все его зависимости для обеспечения запуска приложения прозрачно, быстро и надежно независимо от окружения. Контейнер Docker может быть создан с использованием образа Docker. Это исполняемый пакет программного обеспечения, содержащий все необходимое для запуска приложения, например, системные программы, библиотеки, код, среды исполнения и настройки.
</details>
---

9. Опишите составные части архитектуры Docker
<details>
  <summary>Ответ</summary>

Основные составные части архитектуры Docker — это:

сервер, содержит сервис Docker, образы и контейнеры. Сервис связывается с Registry, образы — метаданные приложений, запускаемых в контейнерах Docker.
клиент, применяется для запуска различных действий на сервере Docker.
registry, используется для хранения образов. Есть публичные, доступные каждому, например, Docker Hub и Docker Cloud.
</details>
---

10. Опишите Registry подробнее
<details>
  <summary>Ответ</summary>

Docker Registry служит для хранения образов Docker. Есть два публичных сервиса хранения: Docker Hub и Docker Cloud. Docker Hub — наиболее значимая публичная система хранения образов контейнеров, полностью поддерживаемая множеством разработчиков и другими участниками сообщества.
</details>
---

11. Расскажите кратко о жизненном цикле контейнера Docker
<details>
  <summary>Ответ</summary>

Жизненный цикл контейнера:

- Создание контейнера
- Работа контейнера
- Приостановка контейнера
- Возобновление работы контейнера
- Запуск контейнера
- Остановка контейнера
- Перезапуск контейнера
- Принудительная остановка контейнера
- Удаление контейнера
</details>
---

12. Назовите наиболее важные команды Docker
<details>
  <summary>Ответ</summary>

Наиболее важные команды Docker:

- build - сборка образа для Docker
- create - создание нового контейнера
- kill - принудительная остановка контейнера
- dockerd - запуск сервиса Docker
- commit - создание нового образа из изменений в контейнере
</details>
---

13. Что такое пространства имен в Docker?
<details>
  <summary>Ответ</summary>

Пространства имен Docker — это технология обеспечения изолированных рабочих пространств, известная как контейнер. Как только контейнер запускается, создается набор пространств имен для этого контейнера. Они обеспечивают уровень изоляции для контейнеров, поскольку каждый контейнер работает в отдельном пространстве имен, с ограничением доступа к другим пространствам.
</details>
---

14. Что такое Docker Swarm?
<details>
  <summary>Ответ</summary>

Docker Swarm (теперь это уже swarm mode) — встроенный инструмент Docker, используемый для организации кластеризации и планирования контейнеров. Разработчики и системные администраторы с его помощью могут легко собрать несколько узлов в единую виртуальную систему Docker и управлять ею.
</details>
---

15. Как определить состояние контейнера Docker?
<details>
  <summary>Ответ</summary>

Чтобы определить состояние, надо запустить команду:

```
docker ps -a
```

Эта команда выведет список всех доступных контейнеров с их состоянием на сервере. Из этого списка нужно выбрать требуемый контейнер и узнать его состояние.
</details>
---

16. Что такое образ Docker, что делает команда Docker run?
<details>
  <summary>Ответ</summary>

Образ Docker — это набор файлов, соединенный с настройками, с помощью которого можно создать экземпляры, которые запускаются в отдельных контейнерах в виде изолированных процессов. Образ строится с использованием инструкций для получения полной исполняемой версии приложения, зависящей от версии ядра сервера. Команда Docker run используется для создания таких экземпляров, называемых контейнерами, запускаемыми с использованием образов Docker. При запуске одного образа пользователь может создать несколько контейнеров.
</details>
---

17. Опишите функции и случаи применения Docker
<details>
  <summary>Ответ</summary>

С помощью Docker можно:

- Сделать процесс настройки проще и упростить настройку на уровне инфраструктуры;
- Помочь разработчикам сосредоточиться исключительно на коде, сокращая время разработки и увеличивая продуктивность;
- Усилить возможности отладки с использованием встроенных функций;
- Изолировать приложения;
- Улучшить плотность использования серверов в форме контейнеризации;
- Делать быстрое развертывание на уровне операционной системы.
</details>
---

18. Что такое объекты Docker?
<details>
  <summary>Ответ</summary>

Под объектами понимают образы, сервисы и контейнеры.
Образы — шаблоны с инструкциями только для чтения для создания контейнеров.
Контейнеры — запущенные экземпляры образов.
Сервисы — можно запустить несколько контейнеров поверх нескольких сервисов Docker, работающих совместно как swarm.

Еще объектами можно назвать сети и тома.
</details>
---

19. Какой тип приложений больше подходит для контейнеров Docker: с хранением состояния (stateful) или без хранения (stateless)?
<details>
  <summary>Ответ</summary>

Приложения без хранения состояния (stateless) больше подходят для работы в Docker, чем приложения с хранением (stateful). Мы можем создать контейнер для нашего приложения и принять некоторые его настройки. Таким образом мы можем запускать один и тот же контейнер с разными настройками для различных окружений. Если мы не будем хранить состояние, сможем использовать один и тот же образ в разных сценариях. Также такие приложения проще масштабировать при их работе в контейнерах Docker.
</details>
---

20. Что такое Dockerfile?
<details>
  <summary>Ответ</summary>

Dockerfile содержит инструкции для сборки образов, которые передаются в Docker. Также его можно описать как текстовый документ, содержащий все возможные команды, с помощью которых пользователь, последовательно их запуская, может собрать образ.
</details>
---

21. Какие сети доступны по умолчанию в Docker?
<details>
  <summary>Ответ</summary>

По умолчанию есть:

- bridge - сеть, к которой подключаются контейнеры, если не указано иначе
- none - сетевой стек без наличия сетевого интерфейса в контейнере
- host - подключение к сетевому стеку сервера
</details>
---

22. Приведите необходимые шаги для развертывания докеризированного приложения, сохраненного в репозитории Git
<details>
  <summary>Ответ</summary>

Шаги, необходимые для развертывания приложения зависят от окружения, основной процесс развертывания будет таким:

- Сборка приложения с использованием Docker build в каталоге с кодом приложения
- Тестирование образа
- Выгрузка образа в Registry
- Уведомление удаленного сервера приложений, что он может скачать образ из Registry и запустить его
- Перестановка порта в прокси HTTP(S)
- Остановка старого контейнера
</details>
---

23. Чем Docker отличается от остальных технологий контейнеризации?
<details>
  <summary>Ответ</summary>

Docker — одна из последних разработок в контейнеризации, он стал одной из наиболее популярных. Docker, созданный в облачную эру, сделал возможным использование новых функций, ранее отсутствующих в старых технологиях контейнеризации. Самая крутая функция Docker — это работа с использованием любой инфраструктуры, неважно, у вас дома, либо в облаке.

Посредством Docker все больше приложений могут работать на старых серверах, также с его помощью можно упаковывать и поставлять программы. Существует также DockerHub, Registry для контейнеров, откуда можно легко и просто скачать образы контейнеров для использования. Еще более интересная функция — общие контейнеры для таких приложений. Также Docker хорошо задокументирован, что делает его лучше остальных технологий контейнеризации.
</details>
---

24. Если вы остановите контейнер — потеряете данные?
<details>
  <summary>Ответ</summary>

Если контейнер Docker останавливается, потери данных не происходит, поскольку все данные пишутся на диск приложением с единственной целью — хранение. Этот процесс повторяется до тех пор, пока контейнер не будет однозначно удален. Более того: файловая система контейнера хранит изменения даже после полной остановки контейнера.
</details>
---

25. Как выполняется мониторинг Docker в производственных окружениях?
<details>
  <summary>Ответ</summary>

Для мониторинга есть инструменты Docker stats и Docker events. С их помощью можно получить отчеты по важной статистике. Если запустить stats с некоторым идентификатором контейнера, он вернет использование оперативной памяти и процессорного времени в контейнере. Это схоже с использованием команды top. С другой стороны есть events, показывающая список активностей в процессе работы сервиса Docker. Вот некоторые из них: подключение к консоли контейнера, commit, переименование, удаление и т.п., а также есть возможность фильтрации нужных событий.
</details>
---

26. Расскажите о рабочем процессе использования Docker
<details>
  <summary>Ответ</summary>

Краткое пояснение рабочего процесса с использованием Docker:

- Все начинается c Dockerfile, поскольку это исходный код образа
- Как только он создан, его можно использовать для сборки образа контейнера. Образ — собранная версия Dockerfile
- Образ можно распространять, используя Registry, работающий как репозиторий образов
- Далее образ используется для запуска контейнеров. Контейнер при работе весьма похож на виртуальную машину, но без гипервизора
</details>
---

27. Поясните разницу между docker run и docker create
<details>
  <summary>Ответ</summary>

Главная разница между этими командами заключается в том, что вторая создаст контейнер в остановленном состоянии. Также docker create может быть использована для хранения и вывода идентификатора контейнера для будущего использования. Лучше всего это делать с помощью docker run, добавляя --cidfile FILENAME, поскольку повторный запуск не перезаписывает файл.
</details>
---

28. Что такое виртуализация?
<details>
  <summary>Ответ</summary>

Виртуализация, как только понятие появилось, обозначала способ логического разделения мейнфреймов для обеспечения одновременной работы нескольких приложений. Но со временем, с появлением в отрасли возможности одновременной работы нескольких операционных систем на одном сервере x86, смысл виртуализации значительно поменялся.

С помощью виртуализации можно запустить две различных операционных системы на одном и том же оборудовании. Первая операционная система используется для административных целей, все остальные гостевые — загружаются как обычно, включая инициализацию, загрузку ядра и т.д. Это также идеально для безопасности, поскольку гостевая ОС не может получить полного доступа к управляющей (host) ОС, что могло бы привести к дырам в безопасности.

Есть три типа виртуализации:
- Паравиртуализация
- Эмуляция
- Контейнерная виртуализация
</details>
---

29. В чем разница между Registry и Repository?
<details>
  <summary>Ответ</summary>

Registry — это сервис хранения и распространения образов, также DockerHub — это Registry по умолчанию. Repository — это набор связанных образов. У них одно и то же имя, но разные метки.
</details>
---

30. Можно ли использовать JSON вместо YAML в файле для docker-compose, если да — как?
<details>
  <summary>Ответ</summary>

Да, так можно сделать. Для этого нужно явно указать имя файла, например так:

```
docker-compose -f docker-compose.json up
```
</details>
---

31. Расскажите о CMD и ENTRYPOINT в Dockerfile
<details>
  <summary>Ответ</summary>

Эти инструкции Dockerfile задают команду, исполняемую при запуске контейнера. При их использовании есть несколько правил, например:

- Должна быть минимум одна из них, CMD или ENTRYPOINT, в Dockerfile
- Если контейнер используется как исполняемый файл — ENTRYPOINT должна быть определена
- Если контейнер запускается с другими аргументами — CMD будет переопределена
</details>
---

32. Опишите процесс запуска приложения внутри контейнера Linux, используя Docker
<details>
  <summary>Ответ</summary>

- Установите и запустите Docker
- Скачайте базовый образ с Docker Hub
- Загрузите ваше приложение в базовый образ
- Запустите контейнер в интерактивном режиме, используя полученный образ
- Проверьте контейнеры в системе
- Запустите или остановите контейнер
- Зайдите внутрь контейнера
- Удалите контейнер и образ
</details>
---

33. Что такое гипервизор?
<details>
  <summary>Ответ</summary>

Гипервизор, он же монитор виртуальных машин, — это программное обеспечение для создания и запуска виртуальных машин. С его помощью можно запустить на одном компьютере несколько гостевых операционных систем. Это достигается с помощью разделения ресурсов, например, оперативной памяти, процессорного времени и т.п., сокращая требования к памяти, дисковому пространству и обслуживанию. Есть два типа гипервизоров:

- первого типа - легковесная операционная система, запускаемая на оборудовании
- второго типа - программное обеспечение, запускаемое из операционной системы
</details>
---

34. Расскажите о ключевом различии между виртуализацией и контейнеризацией
<details>
  <summary>Ответ</summary>

Виртуализация позволяет запустить несколько операционных систем на одном физическом сервере. Контейнеризация работает на одной и той же операционной системе, в которой приложения упакованы в контейнеры и запускаются на одном сервере/виртуальной машине.
</details>
---

35. Расскажите об образах Docker, DockerHub, Dockerfile
<details>
  <summary>Ответ</summary>

**Образы**: файлы, содержащие несколько слоев, используемые для выполнения кода внутри контейнера. Они собираются по инструкциям для получения исполняемой версии приложения. Образы могут ускорить сборку в Docker с помощью кэширования каждого этапа.

**DockerHub**: сервис для поиска и совместного использования образов контейнеров. Вы можете выгружать туда свои образы, скачивать их оттуда, работать с частными репозиториями образов контейнеров, собирать автоматически образы с помощью GitHub (Bitbucket), а затем закачивать их в DockerHub. Этот сервис предоставляет компания Docker.

**Dockerfile**: текстовый файл, используемый для сборки образа. Он содержит инструкции и команды по сборке образа. Docker читает их и автоматически собирает образ.
</details>
---

36. Как проверить версии Docker client и Docker server?
<details>
  <summary>Ответ</summary>

Версию Docker можно проверить с помощью docker version [параметры]. Если не указывать параметры, команда выдаст всю информацию, связанную с версией клиента и сервера. Чтобы получить только версию сервера, можно запустить такую команду:

```
docker version --format '{{.Server.Version}}'
```
</details>
---

37. Расскажите о процедуре входа в Docker Repository
<details>
  <summary>Ответ</summary>

Чтобы войти в Docker Repository, используется следующая команда:

```
docker login [OPTIONS] [SERVER]
```

Например, для входа в registry, размещенную на своих мощностях (локально), команда будет такой:

```
$ docker login localhost:8080
```
</details>
---

38. Расскажите о наиболее общих командах Docker
<details>
  <summary>Ответ</summary>

- docker push: Закачать репозиторий или образ в Registry
- docker run: Запустить команду в новом контейнере
- docker pull: Скачать репозиторий или образ из Registry
- docker start: Запустить один или несколько контейнеров
- docker stop: Остановить один или несколько контейнеров
- docker search: Поиск образа на DockerHub
- docker commit: Сохранить изменения в новый образ
</details>
---

39. Чем отличается контейнеризация в виде Docker от других технологий?
<details>
  <summary>Ответ</summary>

Docker может быть легко развернут в любой облачной платформе. Также разработчики могут создать готовые к запуску контейнеризированные приложения быстрее, могут легко развертывать приложения и управлять ими. Кроме того, контейнеры могут быть общими для приложений. Эти функции не работают в других технологиях контейнеризации.
</details>
---

40. На каких платформах запускается Docker?
<details>
  <summary>Ответ</summary>

Docker работает на Windows (x86_64), Linux (x86_64, ARM, s390x, ppc64le).
</details>
---

41. Возможен ли самостоятельный перезапуск контейнера?
<details>
  <summary>Ответ</summary>

Да, возможен. Docker задает различные политики перезапуска контейнера:

- Off: контейнер не перезапускается, если он остановился или аварийно завершил работу
- On-failure: перезапуск только в случае аварийной остановки, но не по команде пользователя
- Unless-stopped: перезапуск будет работать до тех пор, пока пользователь его не остановит
- Always: перезапуск в любом случае, независимо от ошибок или других проблем

Политику можно задать так:

```
$ docker run -dit — restart [unless-stopped|off|on-failure|always] [CONTAINER]
```
</details>
---

42. Можно ли сравнить облака по возможностям контейнеризации с Docker?
<details>
  <summary>Ответ</summary>

Здесь можно высказать свое мнение, например, я думаю, что несмотря на то, что облака — хороший конкурент, они не смогут заменить контейнеризацию. Большинство компаний используют облака и контейнеризацию вместе, чтобы получить лучшее от обеих технологий.
</details>
---

43. Опишите все возможные состояния контейнера Docker
<details>
  <summary>Ответ</summary>

- Created — контейнер создан, но не активен
- Restarting — контейнер в процессе перезапуска
- Running — контейнер работает
- Paused — контейнер приостановлен
- Exited — контейнер закончил свою работу
- Dead — контейнер, который сервис попытался остановить, но не смог
</details>
---

44. Расскажите о средствах оркестрации и случаях их использования
<details>
  <summary>Ответ</summary>

Оркестрация позволяет управлять работой контейнеров, запущенных в больших и динамических окружениях. С ее помощью можно автоматизировать и управлять следующими задачами:

- Создание и развертывание контейнеров
- Балансировка нагрузки
- Разделение ресурсов между контейнерами
- Мониторинг контейнеров и серверов
- Масштабирование контейнеров
- Перенос контейнеров с одного сервера на другой, если на первом возникает недостаток ресурсов
</details>
---

45. Опишите параметр memory-swap
<details>
  <summary>Ответ</summary>

С помощью параметра memory-swap можно разрешить контейнеру записывать на диск данные, превышающие размер оперативной памяти, выделенной контейнеру. Он работает, только если используется одновременно с параметром memory. Например, если memory = "400m" и memory-swap = "1g", то контейнер может использовать 400мб оперативной памяти и 600мб подкачки (1гб-400мб).
</details>
---

46. Где хранятся тома Docker?
<details>
  <summary>Ответ</summary>

Тома, создаваемые и управляемые Docker (у не-Docker процессов к ним нет доступа), хранятся в файловой системе сервера Docker по пути /var/lib/docker/volumes/. Тома — наиболее эффективный способ сохранения данных в Docker.
</details>
---

47. Назовите продвинутые команды Docker
<details>
  <summary>Ответ</summary>

Наиболее важные из них:

- docker -version: узнать установленную версию Docker
- docker ps: перечислить все запущенные контейнеры вместе с дополнительной информацией о них
- docker ps -a: перечислить все контейнеры, включая остановленные, вместе с дополнительной информацией о них
- docker exec: войти в контейнер и выполнить в нем команду
- docker build: собрать образ из Dockerfile
- docker rm: удалить контейнер с указанным идентификатором
- docker rmi: удалить образ с указанным идентификатором
- docker info: получить расширенную информацию об установленном Docker
- docker cp: сохранить файл из контейнера в локальную систему
- docker history: показать историю образа с указанным именем
</details>
---

48. Расскажите о командах systemd для управления Docker
<details>
  <summary>Ответ</summary>

Для запуска Docker многие дистрибутивы Linux используют systemd. Для запуска сервисов используется команда systemctl. Если ее нет, следует использовать команду service.

```
$ sudo systemctl start docker
$ sudo service docker start
```

Чтобы добавить сервис в автозагрузку, либо убрать его:

```
$ sudo systemctl enable docker
$ sudo systemctl disable docker
```

Для проверки параметров запуска сервиса и их изменения:

```
$ sudo systemctl edit docker
```

Просмотра связанных с сервисом журналов:

```
$ journalctl -u docker
```
</details>
---

49. Опишите процесс масштабирования контейнеров Docker
<details>
  <summary>Ответ</summary>

Контейнеры могут быть масштабированы с использованием команды docker-compose scale. Процесс масштабирования такой:

Масштабируем контейнер и запускаем n экземпляров:
```
$ docker-compose --file docker-compose-run-srvr.yml scale <service_name>=<n>
```

В вышеприведенном примере имя сервиса задается в файле docker-compose-run-srvr.yml, а также запускается n копий контейнеров, где n — любое целое положительное число.

После масштабирования контейнера для проверки можно использовать такую команду:
```
$ docker ps -a
```
</details>
---

50. Что такое CNM?
<details>
  <summary>Ответ</summary>

CNM или Container Network Model — описание, формально определяющее шаги, требуемые для предоставления сети контейнерам, где обслуживающая абстракция применяется для поддержки нескольких сетевых драйверов. CNM основан на трех компонентах: sandbox (песочница), оконечная точка и сеть.
</details>
---

51. Какие типы монтирования доступны в Docker?
<details>
  <summary>Ответ</summary>

- Bind mount: подключаются к любой точке файловой системы сервера
- Volume mount: управляются Docker и хранятся как часть файловой системы сервера
- tmpfs mount: хранятся в оперативной памяти сервера, поэтому никогда не пишутся на реальную файловую систему сервера
</details>
---

52. Расскажите о Docker Trusted Registry
<details>
  <summary>Ответ</summary>

Это хранилище образов для безопасного хранения и управления образами Docker. Его можно установить на своих мощностях, либо в частном облаке. DTR применятся в процессах CI/CD для сборки, поставки и запуска приложений. Его также можно развернуть в отказоустойчивом варианте, есть встроенная система управления доступом.
</details>
---

53. Каково назначение docker_host?
<details>
  <summary>Ответ</summary>

Он задает URL или путь к сокету unix, используемые для соединения с API Docker. Значение по умолчанию — unix://var/run/docker.sock

Для подключения к удаленному серверу обычно используется TCP, например:
tcp://192.0.1.20:3230
</details>
---

54. Возможен ли запуск нескольких копий одного и того же compose файла на одном и том же сервере? Как именно?
<details>
  <summary>Ответ</summary>

Это можно сделать с помощью docker-compose, использующего файл YAML для настройки сервисов приложения. После его создания вы можете в одну команду создать и запустить все сервисы. Для того, чтобы начать им пользоваться:

- Задайте окружение приложения в Dockerfile, так что оно сможет быть реплицировано везде
- Определите все сервисы вашего приложения в файле docker-compose.yml
- Запустите docker-compose up для создания и запуска приложения целиком
</details>
---

55. Объясните метки объектов в Docker
<details>
  <summary>Ответ</summary>

Метки объектов Docker — это пары ключ-значение, сохраняемые в виде строк. Мы можем применить метаданные с их помощью. Метки могут быть применены к любому объекту, например, образу, контейнеру, тому, сети, локальным сервисам, узлам swarm и непосредственно сервисам. Каждая пара должна быть уникальной для объекта, сами метки не меняются динамически на протяжении существования объекта.
</details>
---