## DB basic
<img src="https://raw.githubusercontent.com/vadim-bikmetov/interview/main/images/db.png" width="200" alt="db">

1. Как настроить master-slave репликацию в mysql (кратко)?

<details>
  <summary>Ответ</summary>

Необходимы 2 сервера: master и slave.

1. На обеих сервера устанавливаем сервер MySQL одинаковой версии.
2. Включаем сервер базы данных на обеих серверах.
3. Настраиваем master - в `/etc/my.cnf` устанавливаем слеюущие значения:
```
# выбираем ID сервера, произвольное число, лучше начинать с 1
server-id = 1
# путь к бинарному логу
log_bin = /var/log/mysql/mysql-bin.log
# название Вашей базы данных, которая будет реплицироваться
binlog_do_db = newdatabase
```
Перезапускаем сервер базы данных.
4. Подключаемся к master серверу, создаем пользователя и назначаем ему права для выполнения репликации.
```
mysql -u root -p <пароль root сервера БД>
GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
```
5. На master сервере делаем дамп базы данных c блокировкой таблиц.
```
mysqldump -u root -p --lock-all-tables newdatabase > newdatabase.sql
```
6. Переносим дамп базы на slave сервер, создаем базу данных с таким же именем и импортируем базу.
```
CREATE DATABASE newdatabase;
mysql -u root -p newdatabase < newdatabase.sql
```
7. Настраиваем slave в `/etc/my.cnf`:
```
# ID Слейва, удобно выбирать следующим числом после Мастера
server-id = 2
# Путь к relay логу
relay-log = /var/log/mysql/mysql-relay-bin.log
# Путь к bin логу на Мастере
log_bin = /var/log/mysql/mysql-bin.log
# База данных для репликации
binlog_do_db = newdatabase
```
Перезапускаем сервер базы данных.
8. Запускаем репликацию на slave сервере.
```
CHANGE MASTER TO MASTER_HOST='10.10.0.1', MASTER_USER='slave_user', MASTER_PASSWORD='password',
MASTER_LOG_FILE = 'mysql-bin.000001', MASTER_LOG_POS = 107;
##Указанные значения мы берем из настроек Мастера
После этого запускаем репликацию на Слейве:
START SLAVE;
```
9. Проверяем статус репликации:
```
SHOW SLAVE STATUSG
```

</details>

---

2. Какой тип базы данных использует Prometheus?

<details>
  <summary>Ответ</summary>

Prometheus использует TSDB (time series database).

</details>

---

3. Что такое VACUUM в PostgreSQL?

<details>
  <summary>Ответ</summary>

VACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM. Таким образом, периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.

Без параметра команда VACUUM обрабатывает все таблицы в текущей базе данных, которые может очистить текущий пользователь. Если в параметре передаётся имя таблицы, VACUUM обрабатывает только эту таблицу.

Простая команда VACUUM (без FULL) только высвобождает пространство и делает его доступным для повторного использования. Эта форма команды может работать параллельно с обычными операциями чтения и записи таблицы, так она не требует исключительной блокировки. Однако освобождённое место не возвращается операционной системе (в большинстве случаев); оно просто остаётся доступным для размещения данных этой же таблицы. VACUUM FULL переписывает всё содержимое таблицы в новый файл на диске, не содержащий ничего лишнего, что позволяет возвратить неиспользованное пространство операционной системе. Эта форма работает намного медленнее и запрашивает исключительную блокировку для каждой обрабатываемой таблицы.

</details>

---

4. Репликация и High Availability (HA)

<details>
  <summary>Ответ</summary>

**Основные механизмы репликации:**
- **Физическая репликация (Streaming Replication)** - потоковая передача WAL-файлов на реплики
- **Логическая репликация** - репликация на уровне таблиц (доступна с версии 10+)

**Типы репликации:**
- **Синхронная** - гарантирует сохранность данных, но медленнее
- **Асинхронная** - быстрее, но возможна потеря данных при сбое

**Инструменты для HA:**
- Patroni, Stolon, облачные managed-сервисы (AWS RDS, Google Cloud SQL)
- PgBouncer для балансировки нагрузки на чтение

</details>

---

5. Резервное копирование и восстановление

<details>
  <summary>Ответ</summary>

**Стратегии бэкапов:**
- **Логические бекапы** - `pg_dump`/`pg_dumpall` (просто, но медленно)
- **Физические бекапы** - полные копии данных + WAL-архивирование (основа для PITR)

**Point-in-Time Recovery (PITR):**
1. Восстановить полный физический бекап
2. Скопировать архив WAL-файлов
3. Создать `recovery.signal` и указать целевое время
4. PostgreSQL автоматически накатит WAL-файлы до нужного момента

**Инструменты:** Barman, WAL-G, pgBackRest

</details>

---

6. Мониторинг и производительность

<details>
  <summary>Ответ</summary>

**Ключевые метрики для мониторинга:**
- Нагрузка на CPU и I/O
- Коэффициент попадания в кэш (`buffer_cache_hit_ratio`)
- Количество подключений и репликационный лаг (`replica_lag`)
- Долгие запросы и блокировки

**Диагностика проблем:**
- Включить `log_min_duration_statement` для логирования медленных запросов
- Использовать `EXPLAIN ANALYZE` для анализа планов запросов
- Проверять `pg_stat_activity` и `pg_locks` на предмет блокировок

</details>

---

7. Масштабирование

<details>
  <summary>Ответ</summary>

**Стратегии масштабирования:**
- **Вертикальное (Scale-Up)** - увеличение ресурсов сервера (просто, но дорого)
- **Горизонтальное (Scale-Out)**:
  1. **Репликация на чтение** - запись на мастер, чтение с реплик
  2. **Шардирование** - разделение данных между серверами

**Инструменты шардирования:**
- Citus, CockroachDB, Vitess
- **Применение:** когда данные не помещаются на одном сервере или для multi-tenancy

</details>

---

8. Управление подключениями и пуллинг

<details>
  <summary>Ответ</summary>

**Зачем нужен пуллер соединений:**
- PostgreSQL создает новый процесс для каждого подключения
- Частое открытие/закрытие соединений создает нагрузку
- PgBouncer поддерживает фиксированный пул соединений к БД

**Режимы работы PgBouncer:**
- **Session pooling** - соединение на всю сессию
- **Transaction pooling** - соединение только на время транзакции (наиболее эффективный)
- **Statement pooling** - соединение на один запрос (редко используется)

</details>

---

9. WAL-файлы и их назначение

<details>
  <summary>Ответ</summary>

**WAL (Write-Ahead Log) - механизм предзаписи:**
- Все изменения сначала записываются в WAL, а потом в основные файлы данных
- Обеспечивает надежность и согласованность данных при сбоях

**Основные функции WAL:**
- **Журналирование** - гарантия сохранности данных при аварийных остановках
- **Репликация** - основа для физической репликации
- **Point-in-Time Recovery** - возможность восстановления на любой момент времени
- **Контрольные точки** - регулярная синхронизация WAL и данных

</details>

---

10. Управление WAL-файлами и архивация

<details>
  <summary>Ответ</summary>

**Ключевые параметры конфигурации:**
- `wal_level` - уровень детализации WAL (replica, logical, minimal)
- `archive_mode` - включение/выключение архивации
- `archive_command` - команда для архивации WAL-файлов
- `max_wal_size` - максимальный размер WAL-файлов перед контрольной точкой

**Практические аспекты:**
- Регулярная очистка старых WAL-файлов после контрольных точек
- Мониторинг места на диске для WAL-сегментов
- Настройка надежного хранилища для WAL-архивов (S3, NFS, отдельный диск)
- Использование инструментов типа WAL-G для сжатия и шифрования архивов

</details>

---

# Больше общих вопросов про БД https://datafinder.ru/products/voprosy-dlya-sobesedovaniya-po-sql