## HELM basic
<img src="https://raw.githubusercontent.com/vadim-bikmetov/interview/main/images/helm.png" width="200" alt="git">
1. Что такое Helm?

<details>
  <summary>Ответ</summary>

**Helm** - это менеджер пакетов для Kubernetes. Этот инструмент позволяет нам обернуть Kubernetes приложения в удобные пакеты, называемые чартами, которые можно легко развертывать, обновлять и управлять ими в любой момент времени.

**Чарты** – это пакеты, которые могут включать в себя все для запуска приложения в Kubernetes, от deployments до services. Все это дает возможность работать с приложениями как с единой сущностью, а не как с набором отдельных ресурсов, которые еще и в ручную нужно настраивать...

Так же Helm упрощает управление зависимостями между приложениями, позволяет легко параметризировать настройки приложений через файлы values.yaml и дает возможность повторного использования чартов с помощью шаблонизации.

К тому же можно с легкостью откатиться к предыдущей версии нашего приложения.

</details>

---


2. Что такое **Чарт (Chart)**, **Релиз (Release)** и **Репозиторий (Repository)** в Helm?

<details>
  <summary>Ответ</summary>

Это три ключевые концепции в архитектуре Helm.

*   **Чарт (Chart)** — это упакованное приложение для Kubernetes. Он содержит все необходимые ресурсы (Deployments, Services, ConfigMaps и т.д.), описанные в виде шаблонов, а также файл `Chart.yaml` с метаинформацией и файл `values.yaml` со значениями по умолчанию. Это аналогично форматам `.deb` или `.rpm` в Linux.

*   **Релиз (Release)** — это экземпляр чарта, *развернутый* в Kubernetes-кластере. Один и тот же чарт можно установить много раз в один и тот же кластер, и каждый раз будет создан новый релиз со своим уникальным именем. Helm управляет жизненным циклом каждого релиза.

*   **Репозиторий (Repository)** — это место, где хранятся и откуда можно скачать чарты. Это HTTP-сервер, который содержит файл `index.yaml` с метаданными всех доступных чартов. Это как репозиторий пакетов apt или yum. Примеры: Bitnami, Artifact Hub.

**Простая аналогия:** Репозиторий — это *магазин приложений* (например, App Store), Чарт — это *само приложение в установочном пакете* (например, `app_v1.0.apk`), а Релиз — это *запущенный экземпляр этого приложения* на вашем телефоне.

</details>

---

3. Что такое **Tiller** и почему от него отказались? (Актуально для Helm 2 vs Helm 3)

<details>
  <summary>Ответ</summary>

**Tiller** — это серверный компонент **Helm 2**, который разворачивался внутри кластера Kubernetes. Он отвечал за взаимодействие с Kubernetes API, обработку команд от Helm-клиента и управление состоянием релизов.

**Причины отказа от Tiller в Helm 3:**
1.  **Проблемы безопасности:** Tiller работал под сервисной учетной записью с широкими правами (часто `cluster-admin`) во всем кластере. Любой, у кого был доступ к Tiller, мог выполнять любые операции, что нарушало принцип наименьших привилегий.
2.  **Сложность модели RBAC:** Настройка правильных ролей и разрешений для Tiller была нетривиальной задачей.
3.  **Архитектурная простота:** В Helm 3 клиент напрямую взаимодействует с Kubernetes API, используя конфигурацию `kubectl` и права пользователя (`~/.kube/config`). Это устраняет необходимость в дополнительном серверном компоненте, упрощает установку и повышает безопасность.

**Вывод:** В **Helm 3 Tiller полностью удален**. Теперь Helm работает по безсерверной архитектуре, где клиент берет на себя все функции.

</details>

---

4. Как Helm 3 управляет релизами? Что такое **Secrets как хранилище**?

<details>
  <summary>Ответ</summary>

В Helm 3 состояние каждого релиза (его метаданные, конфигурация, история версий) хранится напрямую в Kubernetes кластере в виде **Secret-объектов** (по умолчанию) или **ConfigMap-объектов**.

*   Каждый релиз получает свой собственный Secret (или ConfigMap) в том же неймспейсе, где он установлен.
*   Имя этого объекта имеет вид `sh.helm.release.v1.<release-name>.<version>`.
*   Данные внутри закодированы в base64 и сжаты.

**Преимущества такого подхода:**
1.  **Отказоустойчивость:** Состояние хранится в кластере, а не локально. Даже если компьютер с Helm-клиентом сгорит, история релизов сохранится.
2.  **Естественное управление доступом:** Доступ к истории релизов контролируется стандартными механизмами Kubernetes RBAC через доступ к Secrets/ConfigMaps.
3.  **Синхронизация:** Несколько пользователей, имеющих доступ к кластеру, видят одинаковое состояние релизов.

Для выбора хранилища можно использовать флаг `--driver` или настройку в `helm env`.

</details>

---

5. Что такое **Шаблонизация (Templating)** в Helm и как работает `templates/` директория?

<details>
  <summary>Ответ</summary>

**Шаблонизация** — это ядро Helm, позволяющее создавать динамические манифесты Kubernetes из шаблонов Go-текст с использованием библиотеки [Go templates](https://pkg.go.dev/text/template) и расширений Sprig.

*   В директории `templates/` чарта находятся файлы шаблонов (например, `deployment.yaml`, `service.yaml`). Это не валидные YAML-файлы, а файлы с множеством вставок в двойных фигурных скобках `{{ ... }}`.
*   Перед установкой чарта Helm **рендерит** эти шаблоны, подставляя в них актуальные значения из:
    *   Файла `values.yaml`.
    *   Файлов, переданных через `--values` или `-f`.
    *   Значений, переданных через `--set` или `--set-file`.
    *   Встроенных объектов, таких как `.Release`, `.Chart`, `.Capabilities`.

**Пример шаблона:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}-{{ .Chart.Name }}
spec:
  replicas: {{ .Values.replicaCount }}
```

После рендеринга с `replicaCount: 3` и релизом `my-app` получится валидный манифест с `replicas: 3` и именем `my-app-mychart`.

</details>

---

6. Как работают зависимости между чартами (`Chart.yaml` и `requirements.yaml`)?

<details>
<summary>Ответ</summary>

В **Helm 3** зависимости между чартами объявляются в файле **`Chart.yaml`** в секции `dependencies:`. Ранее, в Helm 2, для этого использовался отдельный файл `requirements.yaml`.

**Пример секции в `Chart.yaml`:**
```yaml
dependencies:
  - name: postgresql
    version: "~12.0.0"
    repository: "https://charts.bitnami.com/bitnami"
    condition: postgresql.enabled
```

**Как это работает:**
1.  **Объявление:** Зависимости перечисляются с указанием имени, версии, репозитория и опциональных условий (`condition`) или тегов (`tags`).
2.  **Загрузка:** Команда `helm dependency update` скачивает указанные чарты из репозиториев и помещает их в директорию `charts/` вашего чарта в виде архивов (`.tgz`).
3.  **Управление:** Зависимости могут быть включены или отключены динамически с помощью значений в `values.yaml` (через `condition` или `tags`). Например:
    ```yaml
    # values.yaml родительского чарта
    postgresql:
      enabled: true
      auth:
        password: "secret"
    ```
4.  **Установка:** При установке основного чарта все его активные зависимости устанавливаются вместе с ним как часть одного релиза.

Это позволяет создавать сложные приложения (например, "веб-приложение + база данных + кэш") из модульных компонентов.

</details>

---

7. Что такое **Хуки (Hooks)** в Helm и для чего они используются?

<details>
  <summary>Ответ</summary>

**Хуки (Hooks)** — это механизм, позволяющий выполнять определенные действия в ключевые моменты жизненного цикла релиза. Хук — это просто манифест Kubernetes (например, Job или Pod) с специальными аннотациями, которые указывают Helm, *когда* и *как* его запускать.

**Ключевые аннотации:**
*   `helm.sh/hook`: Определяет момент срабатывания (напр., `pre-install`, `post-upgrade`, `pre-rollback`, `test`).
*   `helm.sh/hook-weight`: Число для задания порядка выполнения хуков (от меньшего к большему).
*   `helm.sh/hook-delete-policy`: Определяет, когда хук-ресурс должен быть удален (напр., `hook-succeeded`, `hook-failed`, `before-hook-creation`).

**Типичные use-cases:**
1.  **Настройка БД перед установкой приложения:** Хук `pre-install` типа Job, который запускает миграции схемы базы данных.
2.  **Отправка уведомлений:** Хук `post-upgrade`, отправляющий сообщение в Slack об успешном обновлении.
3.  **Пред- и пост-проверки:** Хук `pre-upgrade`, проверяющий готовность кластера к обновлению.
4.  **Запуск тестов:** Специальный хук `test` (вызываемый через `helm test`) для запуска интеграционных тестов в Pod.

**Важно:** Ресурсы, созданные хуками, не управляются Helm как часть релиза после их выполнения (если не указана политика удаления). Они живут по своим правилам.

</details>

---

8. Какие есть стратегии обновления приложения с помощью Helm?

<details>
  <summary>Ответ</summary>

Helm предоставляет несколько стратегий для обновления (`helm upgrade`) релиза:

1.  **Обновление на основе изменений (`upgrade`):** Стандартная команда. Helm вычисляет diff между текущим состоянием релиза и новой версией чарта/значений и применяет необходимые изменения к ресурсам в Kubernetes. Позволяет менять любые параметры.

2.  **Откат (`rollback`):** Возвращает релиз к любой из предыдущих ревизий (версий) с помощью `helm rollback <RELEASE> <REVISION>`. История хранится в Secrets.

3.  **Повторная установка (`--recreate-pods`) с флагом (устаревший):** В Helm 2 был флаг, который принудительно пересоздавал Pod'ы (даже если манифест Deployment не менялся). В Helm 3 для этого нужно использовать механизмы Kubernetes (например, менять аннотации у Pod-шаблона, чтобы вызвать пересоздание).

4.  **"Синий-Зеленый" деплой или Canary с помощью Helm:** Сам Helm не имеет встроенных сложных стратегий деплоя, но их можно эффективно реализовать, используя возможности Helm:
    *   **Синий-Зеленый:** Установить два разных релиза (например, `myapp-blue` и `myapp-green`) и переключать трафик на уровне Ingress.
    *   **Canary:** Установить основной релиз (`myapp`) и дополнительный canary-релиз (`myapp-canary`) с небольшим количеством реплик и частью трафика, используя возможности Service Mesh или Ingress (например, веса в Nginx Ingress). Для управления этим часто используются более высокоуровневые инструменты (Argo Rollouts, Flagger).

По сути, Helm — это инструмент для декларативного управления манифестами, а стратегии развертывания часто реализуются на уровне самих манифестов или оркестрируются другими инструментами поверх Helm.

</details>

---

9. Что такое `.helmignore` и `.Release` объект?

<details>
  <summary>Ответ</summary>

*   **Файл `.helmignore`** — это файл в корне чарта, который определяет шаблоны файлов, которые следует *игнорировать* при упаковке чарта (команда `helm package`). Работает аналогично `.gitignore`.
    Пример содержимого:
    ```
    # Игнорировать файлы окружения
    env/
    # Игнорировать backup-файлы
    *.bak
    # Не упаковывать тестовые директории
    tests/
    ```
    Это помогает не загромождать чарт ненужными или конфиденциальными файлами.

*   **Объект `.Release`** — это один из встроенных объектов, доступных в шаблонах Helm. Он содержит информацию о текущем *релизе* (экземпляре чарта).
    *   `.Release.Name`: Имя релиза (то, что было указано в `helm install`).
    *   `.Release.Namespace`: Неймспейс, в который установлен релиз.
    *   `.Release.Revision`: Порядковый номер (ревизия) этого релиза. При установке — 1, при каждом `upgrade` увеличивается на 1.
    *   `.Release.Service`: Всегда `"Helm"` (исторически, для различия Helm и Tiller).
    *   `.Release.IsUpgrade`: `true`, если текущая операция — это обновление (`upgrade`) или откат (`rollback`).
    *   `.Release.IsInstall`: `true`, если текущая операция — установка (`install`).

    **Пример использования:** `name: {{ .Release.Name }}-myapp` гарантирует, что имя ресурса будет уникальным для каждого релиза.

</details>

---

10. В чем разница между `helm template` и `helm install --dry-run`?

<details>
  <summary>Ответ</summary>

Обе команды позволяют увидеть, какие именно манифесты будут отправлены в кластер, без фактического выполнения операций. Однако есть ключевые различия:

| Аспект | `helm template` | `helm install/upgrade --dry-run --debug` |
| :--- | :--- | :--- |
| **Основная цель** | **Локальный рендеринг шаблонов.** Генерирует итоговые YAML-манифесты для отладки, CI/CD или использования с другими инструментами (например, `kubectl apply -f -`). | **Проверка установки/обновления в кластере.** Эмулирует реальную операцию установки, чтобы показать, что *произошло бы* в кластере. |
| **Требуется ли кластер?** | **НЕТ.** Работает полностью локально, не нуждается в доступе к Kubernetes API. | **ДА.** Требует подключения к кластеру (файл `kubeconfig`), так как проверяет валидность релиза, загружает зависимости из репозиториев и использует информацию о кластере (например, `.Capabilities`). |
| **Проверка валидности** | Проверяет только синтаксис шаблонов. Не проверяет, будут ли манифесты действительны в конкретном кластере (версии API, поддержка ресурсов). | Выполняет более глубокую проверку, включая валидацию схемы ресурсов на стороне сервера (как `kubectl --dry-run=server`). |
| **Что выводит** | **Только готовые YAML-манифесты.** | **1. NOTES.txt** (если есть), **2. Сгенерированные манифесты**, **3. Дополнительная отладочная информация** от Helm. |
| **Использование в CI/CD** | Часто используется для рендеринга манифестов, которые потом применяются через GitOps-инструменты (Argo CD, Flux). | Используется для финальной проверки перед реальным деплоем, чтобы убедиться, что чарт корректно взаимодействует с целевым кластером. |

**Кратко:** `helm template` — "что получится из этих шаблонов?", `helm install --dry-run` — "что произойдет, если я установлю этот чарт *в этот конкретный кластер*?".

</details>

---